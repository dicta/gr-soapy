# auto-generated by grc.converter

id: soapy_sink
label: Soapy Sink
category: '[soapy]'
flags:
- throttle

parameters:
-   id: type
    label: Input Type
    dtype: enum
    options: [fc32, sc16, sc8]
    option_labels: [Complex Float32, Complex Int16, Complex Byte]
    option_attributes:
        type: [fc32, sc16, sc8]
    hide: part
-   id: devname
    label: Device Type
    dtype: enum
    default: 'driver=uhd'
    options: ['bladerf', 'hackrf', 'lime', 'plutosdr', 'sidekiq', 'uhd', 'xtrxsoapy', 'custom']
    option_labels: ['bladerf', 'hackrf', 'lime', 'plutosdr', 'sidekiq', 'uhd', 'xtrxsoapy', 'custom']
    hide: none
-   id: dev
    label: Device String
    dtype: string
    default: 'uhd'
-   id: args
    label: Args
    dtype: string
-   id: samp_rate
    label: Sampling Rate
    dtype: float
    default: samp_rate
-   id: nchan
    label: Num Channels
    dtype: int
    default: '1'
    hide: part
-   id: clock_rate
    label: Master Clock Rate
    dtype: real
    default: '0'
    hide: part
-   id: clock_source
    label: Clock Source
    dtype: string
    hide: part
-   id: length_tag_name
    label: Length tag name
    dtype: string
-   id: center_freq0
    label: 'Ch0: Center Freq (Hz)'
    category: RF Options
    dtype: real
    default: '100.0e6'
    hide: ${ 'none' if nchan > 0 else 'all' }
-   id: nco_freq0
    label: 'Ch0: NCO Freq (Hz)'
    category: RF Options
    dtype: real
    default: '0'
    hide: ${ 'all' if (devname == 'uhd' or devname == 'plutosdr') else 'part' }
-   id: manual_gain0
    label: 'Ch0: Gain Mode'
    category: RF Options
    dtype: enum
    default: 'True'
    options: ['True', 'False']
    option_labels: [Manual, Auto]
    hide: part
-   id: overall_gain0
    label: 'Ch0: Gain Value'
    category: RF Options
    dtype: real
    default: '10'
    hide: ${ 'none' if ( (devname == 'bladerf' or devname == 'uhd' or devname == 'sidekiq' or devname == 'custom') and manual_gain0 ) else 'all' }
-   id: pga_gain0
    label: 'Ch0: PGA Gain Value'
    category: RF Options
    dtype: float
    default: '24'
    hide: ${ 'none' if ( (devname == 'plutosdr' or devname == 'lime' or devname == 'custom') and manual_gain0) else 'all' }
-   id: pad_gain0
    label: 'Ch0: PAD Gain Value'
    category: RF Options
    dtype: float
    default: '0'
    hide: ${ 'none' if ( ( devname == 'lime'  or devname == 'xtrxsoapy' or devname == 'custom') and manual_gain0 ) else 'all' }
-   id: iamp_gain0
    label: 'Ch0: IAMP Gain Value'
    category: RF Options
    dtype: float
    default: '0'
    hide: ${ 'none' if ( (devname == 'lime' or devname == 'custom') and manual_gain0 ) else 'all' }
-   id: vga_gain0
    label: 'Ch0: VGA Gain Value'
    category: RF Options
    dtype: float
    default: '10'
    hide: ${ 'none' if ( (devname == 'hackrf' or devname == 'custom') and manual_gain0 ) else 'all' }
-   id: amp_gain0
    label: 'Ch0: AMP Gain Value'
    category: RF Options
    dtype: float
    default: '0'
    hide: ${ 'none' if ( (devname == 'hackrf'  or devname == 'custom') and manual_gain0 ) else 'all' }
-   id: ant0
    label: 'Ch0: Antenna'
    category: RF Options
    dtype: string
    default: 'TX'
    hide: ${ 'part' if nchan > 0 else 'all' }
-   id: bw0
    label: 'Ch0: Bandwidth (Hz)'
    category: RF Options
    dtype: real
    default: '0'
    hide: ${ 'part' if nchan > 0 else 'all' }
-   id: dc_offset_auto_mode0
    label: 'Ch0: Automatic DC Offset Mode'
    category: RF Options
    dtype: enum
    default: 'False'
    options: ['False', 'True']
    hide: ${ 'all' if ( devname == 'plutosdr' or devname == 'lime' ) else 'part' }
-   id: dc_offset0
    label: 'Ch0: DC Offset'
    category: RF Options
    dtype: complex
    default: '0'
    hide: ${ 'all' if ( (devname == 'uhd' or devname == 'lime' or devname == 'plutosdr') or dc_offset_auto_mode0 ) else 'part' }
-   id: correction0
    label: 'Ch0: Frequency Correction'
    category: RF Options
    dtype: real
    default: '0'
    hide: ${ 'all' if ( devname == 'uhd' or devname == 'plutosdr' or devname == 'lime') else 'part' }
-   id: balance0
    label: 'Ch0: IQ Balance Correction'
    category: RF Options
    dtype: complex
    default: '0'
    hide: ${ 'all' if ( devname == 'uhd' or devname == 'plutosdr' or devname == 'lime') else 'part' }
-   id: center_freq1
    label: 'Ch1: Center Freq (Hz)'
    category: RF Options
    dtype: real
    default: '100.0e6'
    hide: ${ 'none' if nchan > 1 else 'all' }
-   id: nco_freq1
    label: 'Ch1: NCO Freq (Hz)'
    category: RF Options
    dtype: real
    default: '0'
    hide: 'all'
-   id: manual_gain1
    label: 'Ch1: Gain Mode'
    category: RF Options
    dtype: enum
    default: 'True'
    options: ['True', 'False']
    option_labels: [Manual, Auto]
    hide: ${ 'all' if nchan < 2 else 'part' }
-   id: overall_gain1
    label: 'Ch1: Gain Value'
    category: RF Options
    dtype: real
    default: '0'
    hide: ${ 'none' if nchan >1 and ( (devname == 'bladerf' or devname == 'uhd' or devname == 'plutosdr' or devname == 'lime' or devname == 'custom') and manual_gain1 ) else 'all' }
-   id: pga_gain1
    label: 'Ch1: PGA Gain Value'
    category: RF Options
    dtype: float
    default: '0'
    hide: ${ 'none' if ( (devname == 'plutosdr' or devname == 'lime' or devname == 'custom') and manual_gain1 and nchan > 1) else 'all' }
-   id: pad_gain1
    label: 'Ch1: PAD Gain Value'
    category: RF Options
    dtype: float
    default: '0'
    hide: ${ 'none' if (devname == 'lime' or devname == 'xtrxsoapy' or devname == 'custom') and nchan >1 and manual_gain1 else 'all' }
-   id: iamp_gain1
    label: 'Ch1: IAMP Gain Value'
    category: RF Options
    dtype: float
    default: '0'
    hide: ${ 'none' if (devname == 'lime' or devname == 'custom') and nchan >1 and manual_gain1 else 'all' }
-   id: ant1
    label: 'Ch1: Antenna'
    category: RF Options
    dtype: string
    default: 'TX'
    hide: ${ 'part' if nchan > 1 else 'all' }
-   id: bw1
    label: 'Ch1: Bandwidth (Hz)'
    category: RF Options
    dtype: real
    default: '0'
    hide: ${ 'part' if nchan > 1 else 'all' }
-   id: dc_offset_auto_mode1
    label: 'Ch1: Automatic DC Offset Mode'
    category: RF Options
    dtype: enum
    default: 'False'
    options: ['False', 'True']
    hide: ${ 'all' if nchan <=1 or (devname == 'plutosdr' or devname == 'lime' ) else 'part' }
-   id: dc_offset1
    label: 'Ch1: DC Offset'
    category: RF Options
    dtype: complex
    default: '0'
    hide: ${ 'all' if nchan <=1 or ( devname == 'uhd' or devname == 'plutosdr' or devname == 'lime' ) or dc_offset_auto_mode1 else 'part' }
-   id: correction1
    label: 'Ch1: Frequency Correction'
    category: RF Options
    dtype: real
    default: '0'
    hide: ${ 'all' if nchan <=1 or ( devname == 'uhd' or devname == 'plutosdr' or devname == 'lime' ) else 'part' }
-   id: balance1
    label: 'Ch1: IQ Balance Correction'
    category: RF Options
    dtype: complex
    default: '0'
    hide: ${ 'all' if nchan <=1 or ( devname == 'uhd' or devname == 'plutosdr' or devname == 'lime' ) else 'part' }

inputs:
-   domain: stream
    dtype: ${ type.type }
    multiplicity: ${ nchan }
-   domain: message
    id: command
    optional: True
asserts:
- ${ nchan > 0 }

templates:
    imports: import soapy
    make: |-
        None
        if "${devname}" not in ${dev} and "${devname}" != 'custom':
            print("ERROR: Please check device type and driver string.  Device name is not showing up in the driver string (mismatch?)")
            exit(0)
                    
        self.${id} = soapy.sink(${nchan}, ${dev}, "${devname}", ${args}, ${samp_rate}, "${type}", ${length_tag_name})

        self.${id}.set_gain_mode(0,not ${manual_gain0})
        self.${id}.set_gain_mode(1,not ${manual_gain1})
        
        self.${id}.set_frequency(0, ${center_freq0})
        self.${id}.set_frequency(1, ${center_freq1})

        # Made antenna sanity check more generic
        antList = self.${id}.listAntennas(0)
        
        if len(antList) > 1:
            # If we have more than 1 possible antenna
            if len(${ant0}) == 0 or ${ant0} not in antList:
                print("ERROR: Please define ant0 to an allowed antenna name.")
                strAntList = str(antList).lstrip('(').rstrip(')').rstrip(',')
                print("Allowed antennas: " + strAntList)
                exit(0)

            self.${id}.set_antenna(0,${ant0})
            
        if ${nchan} > 1:
            antList = self.${id}.listAntennas(1)
            # If we have more than 1 possible antenna
            if len(antList) > 1:
                if len(${ant1}) == 0 or ${ant1} not in antList:
                    print("ERROR: Please define ant1 to an allowed antenna name.")
                    strAntList = str(antList).lstrip('(').rstrip(')').rstrip(',')
                    print("Allowed antennas: " + strAntList)
                    exit(0)

                self.${id}.set_antenna(1,${ant1})
                
        # Setup IQ Balance
        if "${devname}" != 'uhd':
            if (self.${id}.hasIQBalance(0)):     
                self.${id}.set_iq_balance(0,${balance0})
            
            if (self.${id}.hasIQBalance(1)):     
                self.${id}.set_iq_balance(1,${balance1})

        # Setup Frequency correction
        if (self.${id}.hasFrequencyCorrection(0)):     
            self.${id}.set_frequency_correction(0,${correction0})
            
        if (self.${id}.hasFrequencyCorrection(1)):     
            self.${id}.set_frequency_correction(1,${correction1})
            
        if "${devname}" == 'uhd' or "${devname}" == 'sidekiq' or "${devname}" == 'bladerf':
            self.${id}.set_overall_gain(0,${overall_gain0}, ${manual_gain0})
            self.${id}.set_overall_gain(1,${overall_gain1}, ${manual_gain1})
        else:
            if "${devname}" == 'custom':
                # If we're here and we're custom, let's still call overall gain
                self.${id}.set_overall_gain(0,${overall_gain0}, ${manual_gain0})
                self.${id}.set_overall_gain(1,${overall_gain1}, ${manual_gain1})
                
            self.${id}.set_gain(0,"PGA", ${pga_gain0}, ${manual_gain0})
            self.${id}.set_gain(1,"PGA", ${pga_gain1}, ${manual_gain1})
            self.${id}.set_gain(0,"PAD", ${pad_gain0}, ${manual_gain0})
            self.${id}.set_gain(1,"PAD", ${pad_gain1}, ${manual_gain1})
            self.${id}.set_gain(0,"IAMP", ${iamp_gain0}, ${manual_gain0})
            self.${id}.set_gain(1,"IAMP", ${iamp_gain1}, ${manual_gain1})

            # Only hackrf uses VGA name, so just ch0
            self.${id}.set_gain(0,"VGA", ${vga_gain0}, ${manual_gain0})
        
    callbacks:
    - set_frequency(0, ${center_freq0})
    - set_frequency(0,"BB",${nco_freq0})
    - set_antenna(1,${ant1})
    - set_bandwidth(1,${bw1})
    - set_antenna(0,${ant0})
    - set_bandwidth(0,${bw0})
    - set_frequency(1, ${center_freq1})
    - set_overall_gain(0,${overall_gain0}, ${manual_gain0})
    - set_overall_gain(1,${overall_gain1}, ${manual_gain1})
    - set_gain(0,"PGA", ${pga_gain0}, ${manual_gain0})
    - set_gain(1,"PGA", ${pga_gain1}, ${manual_gain1})
    - set_gain(0,"PAD", ${pad_gain0}, ${manual_gain0})
    - set_gain(1,"PAD", ${pad_gain1}, ${manual_gain1})
    - set_gain(0,"IAMP", ${iamp_gain0}, ${manual_gain0})
    - set_gain(1,"IAMP", ${iamp_gain1}, ${manual_gain1})
    - set_gain(0,"VGA", ${vga_gain0}, ${manual_gain0})
    - set_gain(0,"AMP", ${amp_gain0}, ${manual_gain0})
    - set_frequency_correction(0,${correction0})
    - set_frequency_correction(1,${correction1})
    - set_iq_balance(0,${balance0})
    - set_iq_balance(1,${balance1})
    - set_dc_offset(0,${dc_offset0},${dc_offset_auto_mode0})
    - set_dc_offset(1,${dc_offset1},${dc_offset_auto_mode1})

documentation: "Soapy Sink Block:\n\nDevice:\nThe device argument is a comma delimited\
    \ string used to create a device\ninstance that uses the specified driver. Device\
    \ driver should always be\nspecified. \nUsage examples:\nDevice: driver=limesdr\n\
    Device: driver=uhd,type=b200\nDevice: driver=uhd,serial=12345678\n\nArgs:\nComma\
    \ delimited list of key-word dictionary arguments specific for each \ndevice.\
    \ Device driver handles internally invalid arguments.\nUsage examples:\nDevice:\
    \ driver=lime\nArgs: skipCal=True\n----------------------\nDevice: driver=airspy\n\
    Args: biastee=true\n\nSample Rate:\nThe sample rate is the number of samples per\
    \ second input by this block.\nIf the requested rate is not possible the driver\
    \ decides internally how\nto handle it.\n\nCenter frequency:\nThe center frequency\
    \ of the RF chain. \nIf the device cannot tune to the specified frequency the\
    \ driver decides\ninternally how to handle it.\n\nMaster Clock Rate:\nThe rate\
    \ of the master clock. \nCan be assigned zero for automatic tuning.\n\nClock Source:\n\
    Specifies a valid external clock source. \nCan be left empty.\n\nInput Type:\n\
    This parameter controls the data type of the stream in gnuradio.\n\nGain:\nDepending\
    \ the device driver specified in the Device field various\ngains parameters can\
    \ be configured. If a driver is not explicitly\nsupported from the block an Overal\
    \ Gain parameter can be configured.\nE.g 1:\nGain Value: 10\nE.g 2:\nDevice: driver=uhd\n\
    PGA Gain: 10\n\nAntenna:\nSpecified antenna used in RF chain.\nCan be left empty\
    \ for auto assignment, else it must correspond to an\nantenna name of the device\
    \ used.\n\nBandwidth:\nThe digital filter bandwidth of the RF chain.\nCan be left\
    \ empty for auto assignment, else it must be a correct filter\nbandwidth of the\
    \ device."

file_format: 1
